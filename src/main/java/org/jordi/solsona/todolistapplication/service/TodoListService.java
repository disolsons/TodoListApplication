package org.jordi.solsona.todolistapplication.service;

import org.jordi.solsona.todolistapplication.api.dto.CreateTodoRequest;
import org.jordi.solsona.todolistapplication.api.dto.UpdateTodoRequest;
import org.jordi.solsona.todolistapplication.commons.mappers.TodoMapper;
import org.jordi.solsona.todolistapplication.domain.model.Todo;
import org.jordi.solsona.todolistapplication.domain.model.TodoStatus;
import org.jordi.solsona.todolistapplication.domain.repository.TodoSpecifications;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.jordi.solsona.todolistapplication.commons.exceptions.TodoNotFoundException;
import org.jordi.solsona.todolistapplication.domain.repository.TodoRepository;
import org.springframework.data.domain.Pageable;
import org.springframework.data.jpa.domain.Specification;
import org.springframework.stereotype.Service;

import java.time.Instant;
import java.util.UUID;

@Service
public class TodoListService {

    private final TodoRepository todoRepository;
    private final TodoMapper mapper;

    @Autowired
    public TodoListService(TodoRepository todoRepository, TodoMapper mapper) {
        this.todoRepository = todoRepository;
        this.mapper = mapper;
    }

    /**
     * Creates a new todo
     * @param request the {@link CreateTodoRequest} to be created
     * @return the created {@link Todo}
     */
    public Todo createTodo(CreateTodoRequest request) {

        //For a distributed system, the id would ideally be generated by the client as sent as part of the request. Since there is no client for this
        //exercise, I am generating the on the server side to simplify the execution, and not have to manually generate new uuid for each request sent
        UUID id = UUID.randomUUID();

        Todo todoEntity = this.mapper.toEntity(request);
        todoEntity.setId(id);
        return this.todoRepository.save(todoEntity);
    }

    /**
     * Get a todo by its id.
     * @param id the todo id
     * @return the {@link Todo} with the parameter id.
     */
    public Todo getTodoById(UUID id) {
        return this.todoRepository.findById(id).orElseThrow(() -> new TodoNotFoundException(id));
    }

    /**
     * Returns a list of todos matching the parameter criteria, and pagination.
     * @param status the status criteria
     * @param dueTime the due time criteria
     * @param pageable the page criteria
     * @return all the {@link Todo} matching the criteria.
     */
    public Page<Todo> list(TodoStatus status, Instant dueTime, Pageable pageable) {

        Specification<Todo> specification = Specification
                .where(TodoSpecifications.hasStatus(status)).and(TodoSpecifications.dueBefore(dueTime));

        return this.todoRepository.findAll(specification, pageable);
    }

    /**
     * Deletes a todo.
     * @param id the id of the {@link Todo} to be deleted.
     */
    public void delete(UUID id) {
        try {
            this.todoRepository.deleteById(id);
        } catch (IllegalArgumentException e) {
            throw new TodoNotFoundException(id);
        }
    }

    /**
     * Updates an existing todo with the values sent in the request.
     * @param id the Id of the {@link Todo} to update.
     * @param request the request payload containing the new values.
     * @return the updated {@link Todo}
     */
    public Todo update(UUID id, UpdateTodoRequest request) {

        Todo toBeUpdated = getTodoById(id);
        toBeUpdated.setName(request.name());
        toBeUpdated.setDescription(request.description());
        toBeUpdated.setDueDate(request.dueDate());
        toBeUpdated.setStatus(request.status());

        return this.todoRepository.save(toBeUpdated);
    }
}
